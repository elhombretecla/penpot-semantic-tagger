{"version":3,"file":"inject.js","sources":["../../src/middleware/inject.ts"],"sourcesContent":["import path from 'node:path';\n\nimport { type Connect } from 'vite';\n\nimport { createDebugger } from '../util/create-debugger.js';\nimport { CLIENT_SCRIPT_NAME } from './client.js';\n\ninterface Options {\n  readonly base: string;\n}\n\nconst RESPONSE_HOOK_SYMBOL = Symbol('vite-live-preview');\n\n/**\n * Middleware that injects the client script into HTML responses.\n */\nexport default ({ base }: Options): Connect.NextHandleFunction => {\n  const debug = createDebugger('live-preview');\n  const clientSrc = JSON.stringify(path.posix.join(base, CLIENT_SCRIPT_NAME));\n\n  return (req, res, next) => {\n    if (!req.headers.accept?.includes('html')) return next();\n\n    // The response has already been hooked. Not sure why this middleware\n    // would be applied to the same response multiple times, but just in\n    // case.\n    if (RESPONSE_HOOK_SYMBOL in res) return next();\n\n    Object.assign(res, { [RESPONSE_HOOK_SYMBOL]: true });\n\n    // XXX: Disable compression so we can intercept the response body.\n    // Vite using compression seems to be undocumented, but it's there\n    // in the source.\n    req.headers['accept-encoding'] = 'identity';\n\n    let hooked = true;\n    let restoreHead: (() => void) | undefined;\n\n    const hookedUrl = req.url;\n    const chunks: Buffer[] = [];\n\n    const writeHead = res.writeHead.bind(res);\n    const write = res.write.bind(res);\n    const end = res.end.bind(res);\n\n    const push = (chunk: unknown, ...args: any[]): boolean => {\n      const encoding = args.find((arg) => typeof arg === 'string');\n      const callback = args.find((arg) => typeof arg === 'function');\n\n      if (typeof chunk === 'string') {\n        chunks.push(Buffer.from(chunk, encoding));\n        callback?.();\n        return true;\n      }\n\n      if (Buffer.isBuffer(chunk)) {\n        chunks.push(chunk);\n        callback?.();\n        return true;\n      }\n\n      return false;\n    };\n\n    const restore: (() => void) | undefined = () => {\n      if (!hooked) return;\n\n      hooked = false;\n\n      let content: string | Buffer | undefined;\n\n      if (chunks.length) {\n        const buffer = Buffer.concat(chunks);\n\n        chunks.length = 0;\n\n        const text = buffer.toString('utf8');\n        const injectIndex = text.search(/<\\/(?:head|body|html)>/iu);\n\n        if (injectIndex >= 0) {\n          content = text.slice(0, injectIndex);\n          content += `<script src=${clientSrc}></script>\\n`;\n          content += text.slice(injectIndex);\n          res.setHeader('Content-Length', Buffer.byteLength(content, 'utf8'));\n          debug?.(`injected client script into \"${req.url}\".`);\n        }\n        else {\n          content = buffer;\n          debug?.(`client script not injected into \"${req.url}\".`);\n        }\n      }\n\n      restoreHead?.();\n      restoreHead = undefined;\n\n      if (content) res.write(content);\n\n      debug?.(`unhooked html request \"${hookedUrl}\".`);\n    };\n\n    res.writeHead = (...args: [any]) => {\n      if (!hooked) return writeHead(...args);\n\n      restoreHead = () => res.writeHead(...args);\n\n      return res;\n    };\n\n    res.write = (chunk: unknown, ...args: any[]) => {\n      if (!hooked) return write(chunk, ...args);\n      if (push(chunk, ...args)) return true;\n\n      // If pushing fails, it means that the chunk type wasn't\n      // supported. Restore the original response. This will also\n      // commit any chunks that were already pushed.\n      debug?.(`unsupported chunk type written to \"${hookedUrl}\".`);\n      restore?.();\n\n      return res.write(chunk, ...args);\n    };\n\n    res.end = (...args: any[]) => {\n      if (!hooked) return end(...args);\n\n      if (args[0] != null && typeof args[0] !== 'function') {\n        res.write(...args as [any?]);\n      }\n\n      // The response is finished. Restore the original response if it\n      // is not already restored.\n      restore?.();\n      res.end();\n\n      return res;\n    };\n\n    debug?.(`hooked html request \"${hookedUrl}\".`);\n    next();\n  };\n};\n"],"names":[],"mappings":"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"}